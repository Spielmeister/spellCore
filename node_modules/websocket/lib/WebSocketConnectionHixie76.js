/************************************************************************
 *  Copyright 2010-2011 Worlize Inc.
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  
 *      http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var crypto = require('crypto');
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var WebSocketFrame = require('./WebSocketFrame');
var BufferList = require('../vendor/FastBufferList');
var Constants = require('./Constants');
//var Validation = require('./Validation').Validation;

const STATE_OPEN = "open";
const STATE_CLOSING = "closing";
const STATE_CLOSED = "closed";

function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
	console.log('Hixie76 style connection');

    this.config = config;
    this.socket = socket;
    this.protocol = protocol;
    this.extensions = extensions;
    this.remoteAddress = socket.remoteAddress;
    this.closeReasonCode = -1;
    this.closeDescription = null;

	this.parser = new Parser();

	var self = this;

	this.parser.on('data', function (packet) {
		self.emit('message', {
	      type: 'utf8',
    	  utf8Data: packet
  		});
	  });
	  this.parser.on('close', function () {
		  this.handleSocketEnd.bind(this);
	  });
	  this.parser.on('error', function () {
		  this.handleSocketEnd.bind(this);
	  });

    // The HTTP Client seems to subscribe to socket error events
    // and re-dispatch them in such a way that doesn't make sense
    // for users of our client, so we want to make sure nobody
    // else is listening for error events on the socket besides us.
    this.socket.removeAllListeners('error');

    this.socket.on('error', this.handleSocketError.bind(this));
    this.socket.on('data', this.handleSocketData.bind(this));
    this.socket.on('end', this.handleSocketEnd.bind(this));
    this.socket.on('close', this.handleSocketClose.bind(this));
    this.socket.on('drain', this.handleSocketDrain.bind(this));
    
    // Disable nagle algorithm?
    this.socket.setNoDelay(this.config.disableNagleAlgorithm);
}

util.inherits(WebSocketConnection, EventEmitter);

WebSocketConnection.prototype.handleSocketData = function(data) {
	this.parser.add(data);
	this.parser.parse();
};

WebSocketConnection.prototype.handleSocketError = function(error) {
    // console.log((new Date()) + " - Socket Error - Closing Connection: " + error);
    if (this.listeners('error').length > 0) {
        this.emit('error', error);
    }
    this.socket.end();
};

WebSocketConnection.prototype.handleSocketEnd = function() {
    // console.log((new Date()) + " - Socket End");
    this.socket.end();
    this.frameQueue = null;
    this.outgoingFrameQueue = [];
    this.fragmentationSize = 0;
    this.bufferList = null;
};

WebSocketConnection.prototype.handleSocketClose = function(hadError) {
    // console.log((new Date()) + " - Socket Close");
    this.socketHadError = hadError;
    this.connected = false;
    this.state = STATE_CLOSED;
    // If closeReasonCode is still set to -1 at this point then we must
    // not have received a close frame!!
    if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = "Connection dropped by remote peer.";
    }
    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        // console.log((new Date()) + " - Emitting WebSocketConnection close event");
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
};

WebSocketConnection.prototype.handleSocketDrain = function() {
    this.outputPaused = false;

};

WebSocketConnection.prototype.close = function() {
    // console.log((new Date()) + " - Initating clean WebSocket close sequence.");
    if (this.connected) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
        this.setCloseTimer();
        this.sendCloseFrame();
        this.state = STATE_CLOSING;
        this.connected = false;
    }
};

WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
    }
    var logText = "WebSocket: Dropping Connection. Code: " + reasonCode.toString(10);
    
    if (typeof(description) !== 'string') {
        // If no description is provided, try to look one up based on the
        // specified reasonCode.
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
    }
    if (description) {
        logText += (" - " + description);
    }
    // console.error((new Date()) + " " + logText);
    
    this.closeReasonCode = reasonCode;
    this.closeDescription = description;
    this.outgoingFrameQueue = [];
    this.frameQueue = [];
    this.fragmentationSize = 0;
    if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description, true);
    }
    this.connected = false;
    this.state = STATE_CLOSED;
    this.closeEventEmitted = true;
    this.emit('close', reasonCode, description);
    this.socket.destroy();
};

WebSocketConnection.prototype.send = function(data) {
    if (Buffer.isBuffer(data)) {
        this.sendBytes(data);
    }
    else if (typeof(data['toString']) === 'function') {
        this.sendUTF(data);
    }
    else {
        throw new Error("Data provided must either be a Node Buffer or implement toString()")
    }
};

WebSocketConnection.prototype.sendUTF = function(data) {
/*	if (this.open) {
    this.drained = false;

    if (this.buffer) {
      this.buffered.push(data);
      return this;
    }

    var length = Buffer.byteLength(data)
      , buffer = new Buffer(2 + length);

    buffer.write('\x00', 'binary');
    buffer.write(data, 1, 'utf8');
    buffer.write('\xff', 1 + length, 'binary');

    try {
      if (this.socket.write(buffer)) {
        this.drained = true;
      }
    } catch (e) {
      this.end();
    }

    this.log.debug(this.name + ' writing', data);
  }
};
*/

	var length = Buffer.byteLength(data), buffer = new Buffer(2 + length);
	buffer.write('\x00', 'binary');
	buffer.write(data, 1, 'utf8');
	buffer.write('\xff', 1 + length, 'binary');
	try {
		this.socket.write(buffer);
	} catch (e) {
		console.log(e);
	}
};
    
WebSocketConnection.prototype.sendBytes = function(data) {
};

/**
 * WebSocket parser
 *
 * @api public
 */

function Parser () {
  this.buffer = '';
  this.i = 0;
};

/**
 * Inherits from EventEmitter.
 */

Parser.prototype.__proto__ = EventEmitter.prototype;

/**
 * Adds data to the buffer.
 *
 * @api public
 */

Parser.prototype.add = function (data) {
  this.buffer += data;
  this.parse();
};

/**
 * Parses the buffer.
 *
 * @api private
 */

Parser.prototype.parse = function () {
  for (var i = this.i, chr, l = this.buffer.length; i < l; i++){
    chr = this.buffer[i];

    if (this.buffer.length == 2 && this.buffer[1] == '\u0000') {
      this.emit('close');
      this.buffer = '';
      this.i = 0;
      return;
    }

    if (i === 0){
      if (chr != '\u0000')
        this.error('Bad framing. Expected null byte as first frame');
      else
        continue;
    }

    if (chr == '\ufffd'){
      this.emit('data', this.buffer.substr(1, i - 1));
      this.buffer = this.buffer.substr(i + 1);
      this.i = 0;
      return this.parse();
    }
  }
};

/**
 * Handles an error
 *
 * @api private
 */

Parser.prototype.error = function (reason) {
  this.buffer = '';
  this.i = 0;
  this.emit('error', reason);
  return this;
};

module.exports = WebSocketConnection;